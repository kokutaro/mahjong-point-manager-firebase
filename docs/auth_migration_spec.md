# 認証機能マイグレーション仕様書

## 1. 概要

現在、本アプリケーションは匿名認証（Anonymous Auth）のみをサポートしています。
これにより手軽に利用開始できる利点がありますが、ブラウザのキャッシュクリアや端末変更、複数デバイス利用時に**個人の成績データ（対戦履歴）が引き継げない**という課題があります。

本仕様書では、**メールアドレス・パスワード認証**を導入し、希望するユーザーがデータを確実に保持・引き継ぎできる仕組み、およびその際のデータ移行フローを定義します。

## 2. 要件定義

### 2.1 認証方式

- **匿名認証（既存）**:
  - アプリ初回アクセス時に自動的に匿名アカウントを作成・ログイン。
  - 現状通り、基本機能は全て利用可能。
- **メール・パスワード認証（新規）**:
  - ユーザーは任意のタイミングでメールアドレスとパスワードを登録可能。
  - 登録後は、別の端末やブラウザからログインすることで、同じユーザーIDとして識別される。

### 2.2 ユーザー体験フロー

#### A. 新規登録（現在のアカウントを永続化）

1. 匿名認証でプレイ中のユーザーが「アカウント登録」または「ログイン」を選択。
2. **アカウント登録**:
   - メールアドレスとパスワードを入力。
   - Firebase Authentication の `linkWithCredential` を使用し、**現在の匿名アカウントをメール認証アカウントに昇格**させる。
   - **データ移行処理**: 不要（UIDが変わらないため）。

#### B. 既存アカウントでログイン（端末引き継ぎ・共有）

1. 別の端末ですでにメール登録済みのユーザーが、新しい端末（または匿名利用中の端末）で「ログイン」を選択。
2. メールアドレスとパスワードでログイン。
3. **データ引き継ぎ確認**:
   - ログイン前のブラウザに「匿名ユーザーとしての対戦履歴」が存在するかチェック。
   - 履歴が存在する場合、ダイアログを表示：
     > 「現在のブラウザにある対戦履歴を、ログイン後のアカウントに統合しますか？」
4. **選択肢**:
   - **「統合する（引き継ぐ）」**:
     - 以前の匿名UID（`oldUid`）に紐づく全てのデータを、ログインしたメール認証UID（`newUid`）に付け替える（データマイグレーション実行）。
   - **「統合しない（破棄する）」**:
     - 現在のブラウザの匿名データは無視され、メール認証アカウントのデータのみが表示される。

## 3. データマイグレーション仕様

### 3.1 対象データ構造

Firestore上のデータ構造は以下の通り（主要部分のみ抜粋）。
ユーザーID（UID）は `rooms` コレクション内の各ドキュメントおよびその内部フィールドに散在しているため、ディープアップデートが必要となる。

- Collection: `rooms`
  - Document: `{roomId}`
    - `playerIds`: `string[]` (UIDの配列)
    - `players`: `Player[]`
      - `id`: `string` (UID)
      - ...
    - `gameResults`: `GameResult[]`
      - `scores`: `PlayerGameResult[]`
        - `playerId`: `string` (UID)
      - `logs`: `HandLog[]`
        - `result`:
          - `winners`: `{ id: UID }[]`
          - `loserId`: `UID` | null
          - `riichiPlayerIds`: `UID[]`
          - `scoreDeltas`: `{ [UID]: number }`
    - `lastEvent`: `LastEvent`
      - `deltas`: `{ [UID]: ScorePointDetail }`

### 3.2 マイグレーションロジック

**条件**: `oldUid`（移行元） から `newUid`（移行先） へデータを付け替える。

1. **クエリ**:
   - `rooms` コレクションから `playerIds` 配列に `oldUid` を含む全てのドキュメントを取得。

2. **更新処理（各Roomドキュメントに対して）**:
   - **トップレベル**:
     - `playerIds`: 配列内の `oldUid` を `newUid` に置換。
     - `players`: 配列内の各オブジェクトについて、`id === oldUid` ならば `newUid` に更新。
   - **履歴データ（GameResults）**:
     - `gameResults` 配列を走査。
     - `scores`: 各要素の `playerId` が `oldUid` なら `newUid` に更新。
     - `logs`:
       - `result.winners`: `id` が `oldUid` なら `newUid` に更新。
       - `result.loserId`: `oldUid` なら `newUid` に更新。
       - `result.riichiPlayerIds`: 配列内の `oldUid` を `newUid` に更新。
       - `result.scoreDeltas`: キーが `oldUid` の値を `newUid` キーに移動。
   - **最終イベント（LastEvent）**:
     - `deltas`: キーが `oldUid` の値を `newUid` キーに移動。

3. **トランザクション**:
   - データの整合性を保つため、可能な限り一括更新またはバッチ処理を行う（対象件数が多い場合は分割バッチ）。

## 4. 画面・UI仕様

### 4.1 メニュー・設定画面

- 「アカウント設定」または「データ引き継ぎ」メニューを追加。
- 未登録（匿名）の場合：「アカウント登録してデータをバックアップ」ボタンを表示。
- 登録・ログイン済みの場合：「ログアウト」ボタンを表示（匿名に戻るか、ログイン画面に戻る）。

### 4.2 アカウント登録モーダル

- 入力：メールアドレス、パスワード。
- アクション：登録（Link）。

### 4.3 ログインモーダル

- 入力：メールアドレス、パスワード。
- アクション：ログイン。
- **移行確認ダイアログ**:
  - 条件：現在の匿名ユーザーで `getUserRoomHistory` が1件以上データを返す場合。
  - メッセージ：「この端末の対戦履歴（X件）が見つかりました。ログインするアカウントにこれらの履歴を追加しますか？」
  - 注意書き：「追加しない場合、この端末の現在の履歴は閲覧できなくなります。」

## 5. 技術的留意点

- **セキュリティルール**:
  - `oldUid` のデータを `newUid` が書き換える操作になるため、マイグレーション実行中は適切な権限管理が必要。
  - 基本的にはクライアントサイドで `oldUid`（現在の匿名ユーザー）としてデータの所有権を持っている状態で操作を行うが、ログイン後は `auth.currentUser` が `newUid` に入れ替わる。
  - したがって、実際のデータ書き換えは **Cloud Functions** などのバックエンドで行うか、あるいはログイン前にデータ取得 -> ログイン -> データ更新 というフローにする必要がある。
  - **推奨フロー（クライアント完結の場合）**:
    1. ログイン前に `oldUid` で更新対象のドキュメントIDリストを取得。
    2. メール認証でログイン（`currentUser` が `newUid` になる）。
    3. `oldUid` のデータを `newUid` に書き換える処理を実行。
    - _注意_: Firestore Security Rules で `playerIds` に自分のIDが含まれていれば書き込みOKとしている場合、`newUid` になってから `oldUid` しか含まれていないドキュメントを書き込めるか？
    - 現行ルール: `resource.data.playerIds` に `request.auth.uid` が含まれている必要がある場合、`newUid` はまだ含まれていないため書き込めない可能性がある。
    - **解決策**:
      - 案A: Security Rules を「`playerIds` に `request.auth.uid` を追加する更新なら許可する」ように緩和する。
      - 案B (推奨): **Cloud Functions (Callable Function)** を実装し、特権環境でデータ移行を行う。クライアントからは `oldUid` を引数で渡す（検証ロジック等のセキュリティ考慮が必要）。

※ 本仕様書では、安全性と確実性を考慮し、データ移行処理は実装難易度に応じて「クライアント処理＋ルール調整」または「Cloud Functions」のいずれかを選択するものとする。まずはクライアント処理での実現可能性を探る。
